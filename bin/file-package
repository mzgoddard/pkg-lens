#!/usr/bin/env node

async function main (options, info) {
  const pkg = JSON.parse(options.source);

  if (pkg.browser) {
    info.dependencies.add(pkg.browser);
  } else if (pkg.main) {
    info.dependencies.add(pkg.main);
  } else if (!pkg.browser && !pkg.main) {
    info.dependencies.add('index.js');
  }

  // if (pkg.bin) {
  //   info.dependencies.add(...Object.values(pkg.bin));
  // }

  return info;
}

async function read(stream) {
  const pieces = [];
  for await (const buf of stream) {
    pieces.push(buf);
  }
  const length = pieces.reduce((a, {length}) => a + length, 0);
  const full = Buffer.alloc(length);
  let index = 0;
  for (const buf of pieces) {
    buf.copy(full, index);
    index += buf.length;
  }
  return full;
}

function toUtf8(buffer) {
  if (typeof TextDecoder !== 'undefined') {
    return new TextDecoder().decode(buffer);
  } else {
    return buffer.toString();
  }
}

async function execute() {
  const options = {
    filename: '',
    filepath: '',
    buffer: null,
    source: '',
  };

  if (process.argv.length > 2) {
    const fs = require('fs');
    const {resolve} = require('path');

    options.filename = process.argv[2];
    options.filepath = resolve(options.filename);
    options.buffer = fs.readFileSync(options.filepath);
  } else {
    // stdin support
    options.buffer = await read(process.stdin);
  }

  options.source = toUtf8(options.buffer);

  const infoBase = {
    bytes: options.buffer.length,
    chars: options.source.length,
    dependencies: new Set(),
    imports: {},
  };

  const info = await main(options, infoBase);

  const infoJSON = Object.assign({}, info);
  infoJSON.dependencies = Array.from(infoJSON.dependencies.values());

  process.stdout.write(JSON.stringify(infoJSON));
}

if (process.mainModule === module) {
  execute();
}
