#!/usr/bin/env node

const parserPath = {
  javascript: require.resolve('./file-javascript'),
  package: require.resolve('./file-package'),
};

async function _fileOne(type, buffer) {
  const {fork} = require('child_process');
  const child = fork(parserPath[type], [], {stdio: 'pipe'});
  child.stdin.end(buffer);
  // child.stderr.pipe(process.stderr);
  // console.error('wait');
  const infoString = await read(child.stdout);
  // console.error(type, 'stdout:', infoString.toString());
  const info = JSON.parse(infoString.toString());
  child.kill();
  // console.error('kill');
  return info;
}

let _fileProcess = {};
function _fileShared(type, buffer) {
  const {fork} = require('child_process');
  if (!_fileProcess[type]) {
    _fileProcess[type] = fork(parserPath[type], [], {stdio: 'pipe'});
    _fileProcess[type].stderr.pipe(process.stderr);
    process.on('exit', () => {
      _fileProcess[type].kill();
    });
  }

  _fileProcess[type].send(buffer);
  return new Promise((resolve, reject) => {
    _fileProcess[type].once('message', fileInfo => {
      resolve(JSON.parse(fileInfo));
    });
  });
}

async function main(options) {
  const {resolve} = require('path');
  const {fork} = require('child_process');

  const maybePackageJson = options.source.startsWith('{');
  const maybeJavascript = true;

  // console.error(options.buffer.length);
  if (maybePackageJson) {
    try {
      return await _fileOne('package', options.buffer);
    } catch (e) {
      // console.error(e.stack);
    }
  }

  return await _fileShared('javascript', options.buffer);
}

async function read(stream) {
  const pieces = [];
  stream.on('end', () => console.error('stream end'));
  for await (const buf of stream) {
    // console.error(buf.length);
    pieces.push(buf);
  }
  // console.error('end');
  const length = pieces.reduce((a, {length}) => a + length, 0);
  const full = Buffer.alloc(length);
  let index = 0;
  for (const buf of pieces) {
    buf.copy(full, index);
    index += buf.length;
  }
  return full;
}

function toUtf8(buffer) {
  if (typeof TextDecoder !== 'undefined') {
    return new TextDecoder().decode(buffer);
  } else {
    return buffer.toString();
  }
}

async function execute() {
  const options = {
    filename: '',
    filepath: '',
    buffer: null,
    source: '',
  };

  if (process.argv.length > 2) {
    const fs = require('fs');
    const {resolve} = require('path');

    options.filename = process.argv[2];
    options.filepath = resolve(options.filename);
    options.buffer = fs.readFileSync(options.filepath);
  } else {
    process.on('message', async filepath => {
      const fs = require('fs');
      const buffer = fs.readFileSync(filepath);
      const source = toUtf8(buffer);
      const options = {
        filename: filepath,
        filepath,
        buffer,
        source,
      };
      process.send(JSON.stringify(await main(options)));
    });

    // stdin support
    // options.source = ...
    options.buffer = await read(process.stdin);
  }

  options.source = toUtf8(options.buffer);

  process.stdout.write(JSON.stringify(await main(options)));
}

if (process.mainModule === module) {
  execute();
}
