#!/usr/bin/env node

async function main (options, info) {
  const {parse: babelParse} = require('@babel/parser');
  const types = require('@babel/types');
  const {traverse: babelWalk} = require('@babel/types');
  const {parse: acornParse} = require('acorn-loose');
  const {simple: simpleWalk} = require('acorn-walk');

  const babelAst = babelParse(options.source);

  const babelState = {
    info,
    scope: {
      node: babelAst,
      variables: {},
    },
    scopes: [],
  };

  babelWalk(babelAst, {
    enter(node, ancestors, state) {
      // {callee: {name: 'require'}, arguments: [{}]}
      const requireArg = types.isCallExpression(node) &&
        types.isIdentifier(node.callee) &&
        node.callee.name === 'require' &&
        node.arguments[0];
      if (types.isStringLiteral(requireArg)) {
        state.info.dependencies.add(requireArg.value);
      }

      const requireResolveArg = types.isMemberExpression(node.callee) &&
        types.isIdentifier(node.callee.object) &&
        node.callee.object.name === 'require' &&
        types.isIdentifier(node.callee.property) &&
        node.callee.property.name === 'resolve' &&
        node.arguments[0];
      if (types.isStringLiteral(requireResolveArg)) {
        state.info.dependencies.add(requireResolveArg.value);
      }

      const importDecl = types.isImportDeclaration(node) && node;
      if (importDecl) {
        state.info.dependencies.add(importDecl.source.value);
      }
    },
    exit(node, ancestors, state) {
      
    },
  }, babelState);

  // console.log(babelAst);

  const acornAst = acornParse(options.source);

  // console.log(acornAst);

  return info;
}

async function read(stream) {
  const pieces = [];
  for await (const buf of stream) {
    pieces.push(buf);
  }
  const length = pieces.reduce((a, {length}) => a + length, 0);
  const full = Buffer.alloc(length);
  let index = 0;
  for (const buf of pieces) {
    buf.copy(full, index);
    index += buf.length;
  }
  return full;
}

async function execute() {
  const fs = require('fs');
  const {resolve} = require('path');

  const options = {
    filename: '',
    filepath: '',
    buffer: null,
    source: '',
  };

  if (process.argv.length > 2) {
    options.filename = process.argv[2];
    options.filepath = resolve(options.filename);
    options.buffer = fs.readFileSync(options.filepath);
  } else {
    // stdin support
    // options.source = ...
    options.buffer = await read(process.stdin);
  }

  options.source = new TextDecoder().decode(options.buffer);

  const infoBase = {
    bytes: options.buffer.length,
    chars: options.source.length,
    dependencies: new Set(),
    imports: {},
  };

  const info = await main(options, infoBase);

  const infoJSON = Object.assign({}, info);
  infoJSON.dependencies = Array.from(infoJSON.dependencies.values());

  process.stdout.write(JSON.stringify(infoJSON));
}

if (process.mainModule === module) {
  execute();
}
