#!/usr/bin/env node

function interopRequire(object) {
  return object.default || object;
}

async function main (options, info) {
  const {parse: babelParse} = require('@babel/parser');
  const types = interopRequire(require('@babel/types/lib/validators/generated'));
  const babelWalk = interopRequire(require('@babel/types/lib/traverse/traverse'));
  // const {parse: acornParse} = require('acorn-loose');
  // const {simple: simpleWalk} = require('acorn-walk');

  const babelAst = babelParse(options.source);

  const babelState = {
    info,
    scope: {
      node: babelAst,
      variables: {},
    },
    scopes: [],
  };

  babelWalk(babelAst, {
    enter(node, ancestors, state) {
      // {callee: {name: 'require'}, arguments: [{}]}
      const requireArg = types.isCallExpression(node) &&
        types.isIdentifier(node.callee) &&
        node.callee.name === 'require' &&
        node.arguments[0];
      if (types.isStringLiteral(requireArg)) {
        state.info.dependencies.add(requireArg.value);
      } else {
        state.info.dependencies.add('*');
      }

      const storeRequire = types.isAssignmentExpression(node) &&
        types.isIdentifier(node.right) && node.right.name === 'require';
      if (storeRequire) {
        state.info.dependencies.add('*');
      }

      const requireResolveArg = types.isCallExpression(node) &&
        types.isMemberExpression(node.callee) &&
        types.isIdentifier(node.callee.object) &&
        node.callee.object.name === 'require' &&
        types.isIdentifier(node.callee.property) &&
        node.callee.property.name === 'resolve' &&
        node.arguments[0];
      if (types.isStringLiteral(requireResolveArg)) {
        state.info.dependencies.add(requireResolveArg.value);
      } else {
        state.info.dependencies.add('*');
      }

      const storeRequireResolve = types.isAssignmentExpression(node) &&
        types.isMemberExpression(node.right) &&
        types.isIdentifier(node.right.object) &&
        node.right.object.name === 'require' &&
        types.isIdentifier(node.right.property) &&
        node.right.property.name === 'resolve';
      if (storeRequireResolve) {
        state.info.dependencies.add('*');
      }

      const importDecl = types.isImportDeclaration(node) && node;
      if (importDecl) {
        state.info.dependencies.add(importDecl.source.value);
      }
    },
    exit(node, ancestors, state) {
      
    },
  }, babelState);

  // console.log(babelAst);

  // const acornAst = acornParse(options.source);

  // console.log(acornAst);

  return info;
}

async function read(stream) {
  const pieces = [];
  for await (const buf of stream) {
    pieces.push(buf);
  }
  const length = pieces.reduce((a, {length}) => a + length, 0);
  const full = Buffer.alloc(length);
  let index = 0;
  for (const buf of pieces) {
    buf.copy(full, index);
    index += buf.length;
  }
  return full;
}

function toUtf8(buffer) {
  if (typeof TextDecoder !== 'undefined') {
    return new TextDecoder().decode(buffer);
  } else {
    return buffer.toString();
  }
}

async function execute() {
  const fs = require('fs');
  const {resolve} = require('path');

  const options = {
    filename: '',
    filepath: '',
    buffer: null,
    source: '',
  };

  // console.error('argv', process.argv);
  if (process.argv.length > 2) {
    options.filename = process.argv[2];
    options.filepath = resolve(options.filename);
    options.buffer = fs.readFileSync(options.filepath);
  } else {
    process.on('message', async buffer => {
      buffer = Buffer.from(buffer);
      const source = toUtf8(buffer);
      const options = {
        filename: '',
        filepath: '',
        buffer,
        source,
      };

      const infoBase = {
        bytes: options.buffer.length,
        chars: options.source.length,
        dependencies: new Set(),
        imports: {},
      };

      const info = await main(options, infoBase);

      const infoJSON = Object.assign({}, info, {
        dependencies: Array.from(info.dependencies),
      });

      process.send(JSON.stringify(infoJSON));
    });

    // stdin support
    // options.source = ...
    // console.error('read');
    options.buffer = await read(process.stdin);
    // console.error('red', options.buffer.length);
  }

  options.source = toUtf8(options.buffer);

  const infoBase = {
    bytes: options.buffer.length,
    chars: options.source.length,
    dependencies: new Set(),
    imports: {},
  };

  // console.error('y');
  const info = await main(options, infoBase);
  // console.error('z');

  const infoJSON = Object.assign({}, info);
  infoJSON.dependencies = Array.from(infoJSON.dependencies.values());

  // console.error('write');
  // console.error(JSON.stringify(infoJSON));
  process.stdout.end(JSON.stringify(infoJSON));
  // console.error('wrote', Buffer.byteLength(JSON.stringify(infoJSON)));

  process.exit(0);
}

if (process.mainModule === module) {
  execute();
}
